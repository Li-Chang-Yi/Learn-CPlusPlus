# 1.一些C++语言基础概念说明，以qt小工程的例子呈现
# 2.使用编译器是Desktop_Qt_5_14_2_MinGW_64_bit，Platform：Window
# 3.比较重要的概念
###3.1封装、继承、多态
继承分三种方式，公有继承、保护继承、私有继承（默认），基类的成员属性在子类中会被改变（公有继承就属性不变，保护继承就全变保护，私有继承就全变私有）

----------
构造函数 & 析构函数(名称与类名相同，创建对象时执行)  
1.构造函数不能是虚函数，析构函数可以是虚函数，原因：调用虚函数，需要vtable，它在构造函数中才被初始化  
2.析构函数通常是虚函数，可以通过基类指针销毁派生类对象，通常在通过基类指针管理对象的场景下  
3.如果基类析构函数不是虚函数，则只会调用基类的析构函数，而不会调用派生类的析构函数

----------
普通构造函数 & 拷贝构造函数`Book(const Book& b)`（本质是对象各部分对应赋值，函数参数一般为对象的引用）

----------
深拷贝和浅拷贝（？） & 显示拷贝和隐式拷贝（`Book book2 = book1;`（显式拷贝） `Book book2(book1);` （隐式拷贝））

----------
友元函数 & 内联函数（？）

----------
静态成员函数 & 普通成员函数（1.对象不存在也能被调用——`类名::函数名`&emsp;2.没有 this 指针&emsp;3.只能访问静态成员）

----------
虚函数 & 纯虚函数（`virtual int area()`&emsp;`virtual int area() = 0;`）   
1.类中存在纯虚函数，不能创建该对象，其类是抽象类，也就是无法实例化  
2.继承这个类的子类必须实现这个纯虚函数，起到规范作用  
3.基类中存在虚函数，子类可以选择不重写这个函数，那么子类的对象调用该虚函数时执行基类中的虚函数实现  
4.后面要override，则把该函数声明为虚函数

----------

静态多态（链接） & 动态多态（链接）  
    
**静态多态实现方式**——**函数重载** （不同的参数类型和数量）和**运算符重载**(针对对象运算如+-等，重定义运算符)  
  
**动态多态实现方式——继承和虚函数**  
1.在基类中声明的虚函数可以在子类中被重写(虚函数即告诉编译器不要链接到基类的该函数)  
2.通过基类的指针或者引用来调用子类的重写的虚函数

----------
虚函数表（vtable）& 虚指针（vptr）——（存储指向类的虚函数的指针 & 指向类的虚函数表）  

当通过基类指针或引用调用虚函数时，运行时会通过虚指针访问虚函数表，从而确定应该调用哪个函数，实现了多态性。

----------
